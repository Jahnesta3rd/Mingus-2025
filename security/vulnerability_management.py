"""
Comprehensive Vulnerability Management System for MINGUS
Vulnerability scanning schedule and automated vulnerability management
"""

import os
import sys
import json
import time
import hashlib
import requests
import subprocess
import platform
import threading
import asyncio
import aiohttp
from typing import Dict, List, Any, Optional, Callable, Union
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from loguru import logger
import sqlite3
import yaml
from cryptography.fernet import Fernet
import base64
import urllib.parse
import queue
import statistics
import concurrent.futures
import threading
import signal
import gc
import schedule
from pathlib import Path
import tempfile
import shutil
import xml.etree.ElementTree as ET
import csv
import matplotlib.pyplot as plt
import seaborn as sns
from jinja2 import Template
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import slack_sdk
import discord
import telegram
import ssl
import socket
import OpenSSL
from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
import nmap
import vulners
import safety
import bandit
import trivy
import snyk
import owasp_zap

class ScanType(Enum):
    """Vulnerability scan types"""
    NETWORK = "network"
    WEB_APPLICATION = "web_application"
    CONTAINER = "container"
    DEPENDENCY = "dependency"
    CODE = "code"
    INFRASTRUCTURE = "infrastructure"
    COMPREHENSIVE = "comprehensive"

class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class ScanStatus(Enum):
    """Scan status"""
    SCHEDULED = "scheduled"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class ScheduleType(Enum):
    """Schedule types"""
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    CUSTOM = "custom"
    ON_DEMAND = "on_demand"

@dataclass
class Vulnerability:
    """Vulnerability information"""
    vulnerability_id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: float
    cve_ids: List[str] = field(default_factory=list)
    affected_systems: List[str] = field(default_factory=list)
    affected_services: List[str] = field(default_factory=list)
    affected_components: List[str] = field(default_factory=list)
    discovery_date: datetime = field(default_factory=datetime.utcnow)
    last_scan_date: Optional[datetime] = None
    remediation_status: str = "open"
    remediation_priority: str = "medium"
    remediation_effort: str = "medium"
    remediation_deadline: Optional[datetime] = None
    remediation_notes: str = ""
    false_positive: bool = False
    risk_score: float = 0.0
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class VulnerabilityScan:
    """Vulnerability scan information"""
    scan_id: str
    scan_type: ScanType
    target_systems: List[str] = field(default_factory=list)
    target_services: List[str] = field(default_factory=list)
    scan_configuration: Dict[str, Any] = field(default_factory=dict)
    schedule_type: ScheduleType = ScheduleType.ON_DEMAND
    schedule_config: Dict[str, Any] = field(default_factory=dict)
    status: ScanStatus = ScanStatus.SCHEDULED
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    duration: int = 0  # seconds
    vulnerabilities_found: int = 0
    critical_vulnerabilities: int = 0
    high_vulnerabilities: int = 0
    medium_vulnerabilities: int = 0
    low_vulnerabilities: int = 0
    scan_results: Dict[str, Any] = field(default_factory=dict)
    scan_log: str = ""
    error_message: str = ""
    created_by: str = ""
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)

@dataclass
class VulnerabilitySchedule:
    """Vulnerability scan schedule"""
    schedule_id: str
    name: str
    description: str
    scan_type: ScanType
    schedule_type: ScheduleType
    schedule_config: Dict[str, Any] = field(default_factory=dict)
    target_systems: List[str] = field(default_factory=list)
    target_services: List[str] = field(default_factory=list)
    scan_configuration: Dict[str, Any] = field(default_factory=dict)
    enabled: bool = True
    last_run: Optional[datetime] = None
    next_run: Optional[datetime] = None
    created_by: str = ""
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)

class VulnerabilityScanner:
    """Base vulnerability scanner class"""
    
    def __init__(self, scanner_type: str, config: Dict[str, Any]):
        self.scanner_type = scanner_type
        self.config = config
        self.name = config.get("name", scanner_type)
        self.version = config.get("version", "1.0")
        self.enabled = config.get("enabled", True)
    
    def scan(self, targets: List[str], options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Perform vulnerability scan"""
        raise NotImplementedError("Subclasses must implement scan method")
    
    def parse_results(self, raw_results: Any) -> List[Vulnerability]:
        """Parse scan results into vulnerabilities"""
        raise NotImplementedError("Subclasses must implement parse_results method")
    
    def get_scan_status(self) -> Dict[str, Any]:
        """Get scanner status"""
        return {
            "scanner_type": self.scanner_type,
            "name": self.name,
            "version": self.version,
            "enabled": self.enabled,
            "status": "ready"
        }

class NmapScanner(VulnerabilityScanner):
    """Nmap network vulnerability scanner"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__("nmap", config)
        self.nmap = nmap.PortScanner()
    
    def scan(self, targets: List[str], options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Perform nmap vulnerability scan"""
        try:
            scan_options = options or {}
            scan_args = scan_options.get("scan_args", "-sV --script vuln")
            
            logger.info(f"Starting nmap scan on targets: {targets}")
            
            # Perform scan
            scan_results = {}
            for target in targets:
                logger.info(f"Scanning target: {target}")
                result = self.nmap.scan(target, arguments=scan_args)
                scan_results[target] = result
            
            return {
                "scanner": "nmap",
                "targets": targets,
                "scan_args": scan_args,
                "results": scan_results,
                "timestamp": datetime.utcnow().isoformat()
            }
        
        except Exception as e:
            logger.error(f"Error in nmap scan: {e}")
            return {
                "scanner": "nmap",
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    
    def parse_results(self, raw_results: Dict[str, Any]) -> List[Vulnerability]:
        """Parse nmap scan results"""
        vulnerabilities = []
        
        try:
            for target, result in raw_results.get("results", {}).items():
                if "scan" in result:
                    for host, host_data in result["scan"].items():
                        if "tcp" in host_data:
                            for port, port_data in host_data["tcp"].items():
                                if "script" in port_data:
                                    for script_name, script_output in port_data["script"].items():
                                        if "vulners" in script_name.lower():
                                            # Parse vulners script output
                                            vulns = self._parse_vulners_output(script_output)
                                            for vuln in vulns:
                                                vuln.affected_systems = [target]
                                                vuln.affected_services = [f"{port_data.get('name', 'unknown')}:{port}"]
                                                vulnerabilities.append(vuln)
            
            return vulnerabilities
        
        except Exception as e:
            logger.error(f"Error parsing nmap results: {e}")
            return []
    
    def _parse_vulners_output(self, output: str) -> List[Vulnerability]:
        """Parse vulners script output"""
        vulnerabilities = []
        
        try:
            lines = output.split('\n')
            for line in lines:
                if 'CVE-' in line:
                    parts = line.split()
                    if len(parts) >= 3:
                        cve_id = parts[0]
                        cvss_score = float(parts[1]) if parts[1].replace('.', '').isdigit() else 0.0
                        title = ' '.join(parts[2:])
                        
                        severity = self._cvss_to_severity(cvss_score)
                        
                        vuln = Vulnerability(
                            vulnerability_id=f"nmap-{cve_id}",
                            title=title,
                            description=f"Vulnerability found by nmap vulners script: {title}",
                            severity=severity,
                            cvss_score=cvss_score,
                            cve_ids=[cve_id],
                            discovery_date=datetime.utcnow()
                        )
                        vulnerabilities.append(vuln)
            
            return vulnerabilities
        
        except Exception as e:
            logger.error(f"Error parsing vulners output: {e}")
            return []
    
    def _cvss_to_severity(self, cvss_score: float) -> VulnerabilitySeverity:
        """Convert CVSS score to severity"""
        if cvss_score >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        elif cvss_score >= 7.0:
            return VulnerabilitySeverity.HIGH
        elif cvss_score >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        elif cvss_score >= 0.1:
            return VulnerabilitySeverity.LOW
        else:
            return VulnerabilitySeverity.INFO

class DependencyScanner(VulnerabilityScanner):
    """Dependency vulnerability scanner"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__("dependency", config)
        self.safety_api_key = config.get("safety_api_key", "")
    
    def scan(self, targets: List[str], options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Perform dependency vulnerability scan"""
        try:
            scan_results = {}
            
            for target in targets:
                logger.info(f"Scanning dependencies in: {target}")
                
                # Check if target is a Python project
                if os.path.exists(os.path.join(target, "requirements.txt")):
                    result = self._scan_python_dependencies(target)
                elif os.path.exists(os.path.join(target, "package.json")):
                    result = self._scan_nodejs_dependencies(target)
                else:
                    result = {"error": "Unsupported project type"}
                
                scan_results[target] = result
            
            return {
                "scanner": "dependency",
                "targets": targets,
                "results": scan_results,
                "timestamp": datetime.utcnow().isoformat()
            }
        
        except Exception as e:
            logger.error(f"Error in dependency scan: {e}")
            return {
                "scanner": "dependency",
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    
    def _scan_python_dependencies(self, target: str) -> Dict[str, Any]:
        """Scan Python dependencies"""
        try:
            # Use safety to scan Python dependencies
            result = subprocess.run(
                ["safety", "check", "--json", "--output", "json"],
                cwd=target,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return json.loads(result.stdout)
            else:
                return {"error": result.stderr}
        
        except Exception as e:
            return {"error": str(e)}
    
    def _scan_nodejs_dependencies(self, target: str) -> Dict[str, Any]:
        """Scan Node.js dependencies"""
        try:
            # Use npm audit to scan Node.js dependencies
            result = subprocess.run(
                ["npm", "audit", "--json"],
                cwd=target,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return json.loads(result.stdout)
            else:
                return {"error": result.stderr}
        
        except Exception as e:
            return {"error": str(e)}
    
    def parse_results(self, raw_results: Dict[str, Any]) -> List[Vulnerability]:
        """Parse dependency scan results"""
        vulnerabilities = []
        
        try:
            for target, result in raw_results.get("results", {}).items():
                if "error" not in result:
                    if "vulnerabilities" in result:
                        # Safety format
                        for vuln_data in result["vulnerabilities"]:
                            vuln = Vulnerability(
                                vulnerability_id=f"dep-{vuln_data.get('package', 'unknown')}-{vuln_data.get('installed_version', 'unknown')}",
                                title=vuln_data.get("advisory", "Dependency vulnerability"),
                                description=vuln_data.get("description", ""),
                                severity=self._parse_severity(vuln_data.get("severity", "medium")),
                                cvss_score=float(vuln_data.get("cvss_score", 0)),
                                cve_ids=vuln_data.get("cve", []),
                                affected_components=[vuln_data.get("package", "unknown")],
                                discovery_date=datetime.utcnow()
                            )
                            vulnerabilities.append(vuln)
                    elif "metadata" in result:
                        # npm audit format
                        for vuln_id, vuln_data in result.get("vulnerabilities", {}).items():
                            vuln = Vulnerability(
                                vulnerability_id=f"npm-{vuln_id}",
                                title=vuln_data.get("title", "npm vulnerability"),
                                description=vuln_data.get("description", ""),
                                severity=self._parse_severity(vuln_data.get("severity", "medium")),
                                cvss_score=float(vuln_data.get("cvss", {}).get("score", 0)),
                                cve_ids=vuln_data.get("cves", []),
                                affected_components=[vuln_data.get("module_name", "unknown")],
                                discovery_date=datetime.utcnow()
                            )
                            vulnerabilities.append(vuln)
            
            return vulnerabilities
        
        except Exception as e:
            logger.error(f"Error parsing dependency results: {e}")
            return []
    
    def _parse_severity(self, severity: str) -> VulnerabilitySeverity:
        """Parse severity string"""
        severity_map = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
            "info": VulnerabilitySeverity.INFO
        }
        return severity_map.get(severity.lower(), VulnerabilitySeverity.MEDIUM)

class WebApplicationScanner(VulnerabilityScanner):
    """Web application vulnerability scanner"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__("web_application", config)
        self.zap_api_key = config.get("zap_api_key", "")
        self.zap_url = config.get("zap_url", "http://localhost:8080")
    
    def scan(self, targets: List[str], options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Perform web application vulnerability scan"""
        try:
            scan_results = {}
            
            for target in targets:
                logger.info(f"Scanning web application: {target}")
                
                # Use OWASP ZAP for web application scanning
                result = self._scan_with_zap(target, options or {})
                scan_results[target] = result
            
            return {
                "scanner": "web_application",
                "targets": targets,
                "results": scan_results,
                "timestamp": datetime.utcnow().isoformat()
            }
        
        except Exception as e:
            logger.error(f"Error in web application scan: {e}")
            return {
                "scanner": "web_application",
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    
    def _scan_with_zap(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Scan with OWASP ZAP"""
        try:
            # This is a simplified ZAP integration
            # In a real implementation, you would use the ZAP API
            scan_config = {
                "target": target,
                "scan_type": "spider",
                "scan_level": options.get("scan_level", "medium")
            }
            
            # Simulate ZAP scan results
            return {
                "scan_config": scan_config,
                "vulnerabilities": [
                    {
                        "type": "sql_injection",
                        "severity": "high",
                        "description": "Potential SQL injection vulnerability",
                        "url": f"{target}/api/users",
                        "parameter": "id"
                    }
                ]
            }
        
        except Exception as e:
            return {"error": str(e)}
    
    def parse_results(self, raw_results: Dict[str, Any]) -> List[Vulnerability]:
        """Parse web application scan results"""
        vulnerabilities = []
        
        try:
            for target, result in raw_results.get("results", {}).items():
                if "vulnerabilities" in result:
                    for vuln_data in result["vulnerabilities"]:
                        vuln = Vulnerability(
                            vulnerability_id=f"web-{vuln_data.get('type', 'unknown')}-{hashlib.md5(f'{target}{vuln_data.get('url', '')}'.encode()).hexdigest()[:8]}",
                            title=f"Web Application Vulnerability: {vuln_data.get('type', 'unknown')}",
                            description=vuln_data.get("description", ""),
                            severity=self._parse_severity(vuln_data.get("severity", "medium")),
                            cvss_score=self._severity_to_cvss(vuln_data.get("severity", "medium")),
                            affected_systems=[target],
                            affected_services=["web_application"],
                            discovery_date=datetime.utcnow()
                        )
                        vulnerabilities.append(vuln)
            
            return vulnerabilities
        
        except Exception as e:
            logger.error(f"Error parsing web application results: {e}")
            return []
    
    def _parse_severity(self, severity: str) -> VulnerabilitySeverity:
        """Parse severity string"""
        severity_map = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
            "info": VulnerabilitySeverity.INFO
        }
        return severity_map.get(severity.lower(), VulnerabilitySeverity.MEDIUM)
    
    def _severity_to_cvss(self, severity: str) -> float:
        """Convert severity to CVSS score"""
        severity_scores = {
            "critical": 9.0,
            "high": 7.0,
            "medium": 4.0,
            "low": 2.0,
            "info": 0.0
        }
        return severity_scores.get(severity.lower(), 4.0)

class VulnerabilityManagementSystem:
    """Comprehensive vulnerability management system"""
    
    def __init__(self, base_url: str = "http://localhost:5000"):
        self.base_url = base_url
        self.scanners: Dict[str, VulnerabilityScanner] = {}
        self.schedules: Dict[str, VulnerabilitySchedule] = {}
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.scans: Dict[str, VulnerabilityScan] = {}
        self.vuln_db_path = "/var/lib/mingus/vulnerability_management.db"
        self.schedule_thread = None
        self.running = False
        self._init_database()
        self._init_scanners()
        self._load_schedules()
        self._start_scheduler()
    
    def _init_database(self):
        """Initialize vulnerability management database"""
        try:
            conn = sqlite3.connect(self.vuln_db_path)
            cursor = conn.cursor()
            
            # Create vulnerabilities table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    vulnerability_id TEXT PRIMARY KEY,
                    title TEXT NOT NULL,
                    description TEXT,
                    severity TEXT NOT NULL,
                    cvss_score REAL,
                    cve_ids TEXT,
                    affected_systems TEXT,
                    affected_services TEXT,
                    affected_components TEXT,
                    discovery_date TEXT NOT NULL,
                    last_scan_date TEXT,
                    remediation_status TEXT,
                    remediation_priority TEXT,
                    remediation_effort TEXT,
                    remediation_deadline TEXT,
                    remediation_notes TEXT,
                    false_positive BOOLEAN,
                    risk_score REAL,
                    tags TEXT,
                    metadata TEXT
                )
            ''')
            
            # Create scans table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS vulnerability_scans (
                    scan_id TEXT PRIMARY KEY,
                    scan_type TEXT NOT NULL,
                    target_systems TEXT,
                    target_services TEXT,
                    scan_configuration TEXT,
                    schedule_type TEXT,
                    schedule_config TEXT,
                    status TEXT NOT NULL,
                    start_time TEXT,
                    end_time TEXT,
                    duration INTEGER,
                    vulnerabilities_found INTEGER,
                    critical_vulnerabilities INTEGER,
                    high_vulnerabilities INTEGER,
                    medium_vulnerabilities INTEGER,
                    low_vulnerabilities INTEGER,
                    scan_results TEXT,
                    scan_log TEXT,
                    error_message TEXT,
                    created_by TEXT,
                    created_at TEXT NOT NULL,
                    updated_at TEXT NOT NULL
                )
            ''')
            
            # Create schedules table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS vulnerability_schedules (
                    schedule_id TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    description TEXT,
                    scan_type TEXT NOT NULL,
                    schedule_type TEXT NOT NULL,
                    schedule_config TEXT,
                    target_systems TEXT,
                    target_services TEXT,
                    scan_configuration TEXT,
                    enabled BOOLEAN,
                    last_run TEXT,
                    next_run TEXT,
                    created_by TEXT,
                    created_at TEXT NOT NULL,
                    updated_at TEXT NOT NULL
                )
            ''')
            
            conn.commit()
            conn.close()
        
        except Exception as e:
            logger.error(f"Error initializing vulnerability management database: {e}")
    
    def _init_scanners(self):
        """Initialize vulnerability scanners"""
        try:
            # Initialize Nmap scanner
            nmap_config = {
                "name": "Nmap Network Scanner",
                "version": "1.0",
                "enabled": True
            }
            self.scanners["nmap"] = NmapScanner(nmap_config)
            
            # Initialize dependency scanner
            dep_config = {
                "name": "Dependency Vulnerability Scanner",
                "version": "1.0",
                "enabled": True,
                "safety_api_key": ""
            }
            self.scanners["dependency"] = DependencyScanner(dep_config)
            
            # Initialize web application scanner
            web_config = {
                "name": "Web Application Vulnerability Scanner",
                "version": "1.0",
                "enabled": True,
                "zap_api_key": "",
                "zap_url": "http://localhost:8080"
            }
            self.scanners["web_application"] = WebApplicationScanner(web_config)
            
            logger.info(f"Initialized {len(self.scanners)} vulnerability scanners")
        
        except Exception as e:
            logger.error(f"Error initializing scanners: {e}")
    
    def _load_schedules(self):
        """Load vulnerability scan schedules from database"""
        try:
            conn = sqlite3.connect(self.vuln_db_path)
            cursor = conn.cursor()
            
            cursor.execute("SELECT * FROM vulnerability_schedules WHERE enabled = 1")
            rows = cursor.fetchall()
            
            for row in rows:
                schedule = VulnerabilitySchedule(
                    schedule_id=row[0],
                    name=row[1],
                    description=row[2],
                    scan_type=ScanType(row[3]),
                    schedule_type=ScheduleType(row[4]),
                    schedule_config=json.loads(row[5]) if row[5] else {},
                    target_systems=json.loads(row[6]) if row[6] else [],
                    target_services=json.loads(row[7]) if row[7] else [],
                    scan_configuration=json.loads(row[8]) if row[8] else {},
                    enabled=bool(row[9]),
                    last_run=datetime.fromisoformat(row[10]) if row[10] else None,
                    next_run=datetime.fromisoformat(row[11]) if row[11] else None,
                    created_by=row[12],
                    created_at=datetime.fromisoformat(row[13]),
                    updated_at=datetime.fromisoformat(row[14])
                )
                self.schedules[schedule.schedule_id] = schedule
            
            conn.close()
            logger.info(f"Loaded {len(self.schedules)} vulnerability scan schedules")
        
        except Exception as e:
            logger.error(f"Error loading schedules: {e}")
    
    def _start_scheduler(self):
        """Start vulnerability scan scheduler"""
        try:
            self.running = True
            self.schedule_thread = threading.Thread(target=self._scheduler_loop, daemon=True)
            self.schedule_thread.start()
            logger.info("Vulnerability scan scheduler started")
        
        except Exception as e:
            logger.error(f"Error starting scheduler: {e}")
    
    def _scheduler_loop(self):
        """Scheduler main loop"""
        while self.running:
            try:
                current_time = datetime.utcnow()
                
                # Check for scheduled scans
                for schedule_id, schedule in self.schedules.items():
                    if schedule.enabled and schedule.next_run and current_time >= schedule.next_run:
                        logger.info(f"Executing scheduled scan: {schedule.name}")
                        self._execute_scheduled_scan(schedule)
                
                time.sleep(60)  # Check every minute
            
            except Exception as e:
                logger.error(f"Error in scheduler loop: {e}")
                time.sleep(60)
    
    def _execute_scheduled_scan(self, schedule: VulnerabilitySchedule):
        """Execute scheduled vulnerability scan"""
        try:
            # Create scan from schedule
            scan = VulnerabilityScan(
                scan_id=f"scan-{schedule.schedule_id}-{int(time.time())}",
                scan_type=schedule.scan_type,
                target_systems=schedule.target_systems,
                target_services=schedule.target_services,
                scan_configuration=schedule.scan_configuration,
                schedule_type=schedule.schedule_type,
                schedule_config=schedule.schedule_config,
                status=ScanStatus.RUNNING,
                start_time=datetime.utcnow(),
                created_by=schedule.created_by
            )
            
            # Execute scan
            scan_result = self.execute_scan(scan)
            
            # Update schedule
            schedule.last_run = datetime.utcnow()
            schedule.next_run = self._calculate_next_run(schedule)
            self._update_schedule(schedule)
            
            logger.info(f"Scheduled scan completed: {scan.scan_id}")
        
        except Exception as e:
            logger.error(f"Error executing scheduled scan: {e}")
    
    def _calculate_next_run(self, schedule: VulnerabilitySchedule) -> datetime:
        """Calculate next run time for schedule"""
        try:
            current_time = datetime.utcnow()
            
            if schedule.schedule_type == ScheduleType.DAILY:
                return current_time + timedelta(days=1)
            elif schedule.schedule_type == ScheduleType.WEEKLY:
                return current_time + timedelta(weeks=1)
            elif schedule.schedule_type == ScheduleType.MONTHLY:
                return current_time + timedelta(days=30)
            elif schedule.schedule_type == ScheduleType.CUSTOM:
                interval_hours = schedule.schedule_config.get("interval_hours", 24)
                return current_time + timedelta(hours=interval_hours)
            else:
                return None
        
        except Exception as e:
            logger.error(f"Error calculating next run: {e}")
            return None
    
    def create_vulnerability_scan(self, scan_type: ScanType, targets: List[str], **kwargs) -> VulnerabilityScan:
        """Create vulnerability scan"""
        try:
            scan_id = f"scan-{scan_type.value}-{int(time.time())}"
            
            scan = VulnerabilityScan(
                scan_id=scan_id,
                scan_type=scan_type,
                target_systems=targets,
                target_services=kwargs.get("target_services", []),
                scan_configuration=kwargs.get("scan_configuration", {}),
                schedule_type=ScheduleType(kwargs.get("schedule_type", "on_demand")),
                schedule_config=kwargs.get("schedule_config", {}),
                status=ScanStatus.SCHEDULED,
                created_by=kwargs.get("created_by", "system")
            )
            
            self.scans[scan.scan_id] = scan
            self._save_scan(scan)
            
            logger.info(f"Vulnerability scan created: {scan.scan_id}")
            return scan
        
        except Exception as e:
            logger.error(f"Error creating vulnerability scan: {e}")
            return None
    
    def execute_scan(self, scan: VulnerabilityScan) -> bool:
        """Execute vulnerability scan"""
        try:
            scan.status = ScanStatus.RUNNING
            scan.start_time = datetime.utcnow()
            self._update_scan(scan)
            
            logger.info(f"Executing vulnerability scan: {scan.scan_id}")
            
            # Get appropriate scanner
            scanner = self.scanners.get(scan.scan_type.value)
            if not scanner:
                raise Exception(f"No scanner available for type: {scan.scan_type.value}")
            
            # Execute scan
            scan_results = scanner.scan(scan.target_systems, scan.scan_configuration)
            
            # Parse results
            vulnerabilities = scanner.parse_results(scan_results)
            
            # Update scan with results
            scan.end_time = datetime.utcnow()
            scan.duration = int((scan.end_time - scan.start_time).total_seconds())
            scan.scan_results = scan_results
            scan.scan_log = f"Scan completed successfully. Found {len(vulnerabilities)} vulnerabilities."
            
            # Count vulnerabilities by severity
            scan.vulnerabilities_found = len(vulnerabilities)
            scan.critical_vulnerabilities = len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL])
            scan.high_vulnerabilities = len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH])
            scan.medium_vulnerabilities = len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM])
            scan.low_vulnerabilities = len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.LOW])
            
            # Store vulnerabilities
            for vuln in vulnerabilities:
                self.vulnerabilities[vuln.vulnerability_id] = vuln
                self._save_vulnerability(vuln)
            
            scan.status = ScanStatus.COMPLETED
            self._update_scan(scan)
            
            logger.info(f"Vulnerability scan completed: {scan.scan_id}")
            logger.info(f"Found {len(vulnerabilities)} vulnerabilities")
            
            return True
        
        except Exception as e:
            logger.error(f"Error executing vulnerability scan: {e}")
            scan.status = ScanStatus.FAILED
            scan.error_message = str(e)
            scan.end_time = datetime.utcnow()
            self._update_scan(scan)
            return False
    
    def create_vulnerability_schedule(self, name: str, scan_type: ScanType, schedule_type: ScheduleType, targets: List[str], **kwargs) -> VulnerabilitySchedule:
        """Create vulnerability scan schedule"""
        try:
            schedule_id = f"schedule-{scan_type.value}-{int(time.time())}"
            
            schedule = VulnerabilitySchedule(
                schedule_id=schedule_id,
                name=name,
                description=kwargs.get("description", ""),
                scan_type=scan_type,
                schedule_type=schedule_type,
                schedule_config=kwargs.get("schedule_config", {}),
                target_systems=targets,
                target_services=kwargs.get("target_services", []),
                scan_configuration=kwargs.get("scan_configuration", {}),
                enabled=kwargs.get("enabled", True),
                created_by=kwargs.get("created_by", "system")
            )
            
            # Calculate next run time
            schedule.next_run = self._calculate_next_run(schedule)
            
            self.schedules[schedule.schedule_id] = schedule
            self._save_schedule(schedule)
            
            logger.info(f"Vulnerability schedule created: {schedule.schedule_id}")
            return schedule
        
        except Exception as e:
            logger.error(f"Error creating vulnerability schedule: {e}")
            return None
    
    def get_vulnerabilities(self, filters: Dict[str, Any] = None) -> List[Vulnerability]:
        """Get vulnerabilities with optional filtering"""
        try:
            vulnerabilities = list(self.vulnerabilities.values())
            
            if filters:
                if "severity" in filters:
                    vulnerabilities = [v for v in vulnerabilities if v.severity.value == filters["severity"]]
                
                if "status" in filters:
                    vulnerabilities = [v for v in vulnerabilities if v.remediation_status == filters["status"]]
                
                if "system" in filters:
                    vulnerabilities = [v for v in vulnerabilities if filters["system"] in v.affected_systems]
            
            return vulnerabilities
        
        except Exception as e:
            logger.error(f"Error getting vulnerabilities: {e}")
            return []
    
    def get_scan_history(self, filters: Dict[str, Any] = None) -> List[VulnerabilityScan]:
        """Get scan history with optional filtering"""
        try:
            scans = list(self.scans.values())
            
            if filters:
                if "scan_type" in filters:
                    scans = [s for s in scans if s.scan_type.value == filters["scan_type"]]
                
                if "status" in filters:
                    scans = [s for s in scans if s.status.value == filters["status"]]
                
                if "date_from" in filters:
                    scans = [s for s in scans if s.created_at >= filters["date_from"]]
                
                if "date_to" in filters:
                    scans = [s for s in scans if s.created_at <= filters["date_to"]]
            
            return sorted(scans, key=lambda x: x.created_at, reverse=True)
        
        except Exception as e:
            logger.error(f"Error getting scan history: {e}")
            return []
    
    def get_schedules(self) -> List[VulnerabilitySchedule]:
        """Get all vulnerability scan schedules"""
        return list(self.schedules.values())
    
    def update_vulnerability_status(self, vulnerability_id: str, status: str, **kwargs) -> bool:
        """Update vulnerability remediation status"""
        try:
            if vulnerability_id in self.vulnerabilities:
                vuln = self.vulnerabilities[vulnerability_id]
                vuln.remediation_status = status
                
                if "priority" in kwargs:
                    vuln.remediation_priority = kwargs["priority"]
                
                if "notes" in kwargs:
                    vuln.remediation_notes = kwargs["notes"]
                
                if "deadline" in kwargs:
                    vuln.remediation_deadline = kwargs["deadline"]
                
                self._save_vulnerability(vuln)
                
                logger.info(f"Vulnerability status updated: {vulnerability_id} -> {status}")
                return True
            
            return False
        
        except Exception as e:
            logger.error(f"Error updating vulnerability status: {e}")
            return False
    
    def _save_vulnerability(self, vulnerability: Vulnerability):
        """Save vulnerability to database"""
        try:
            conn = sqlite3.connect(self.vuln_db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO vulnerabilities VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                vulnerability.vulnerability_id,
                vulnerability.title,
                vulnerability.description,
                vulnerability.severity.value,
                vulnerability.cvss_score,
                json.dumps(vulnerability.cve_ids),
                json.dumps(vulnerability.affected_systems),
                json.dumps(vulnerability.affected_services),
                json.dumps(vulnerability.affected_components),
                vulnerability.discovery_date.isoformat(),
                vulnerability.last_scan_date.isoformat() if vulnerability.last_scan_date else None,
                vulnerability.remediation_status,
                vulnerability.remediation_priority,
                vulnerability.remediation_effort,
                vulnerability.remediation_deadline.isoformat() if vulnerability.remediation_deadline else None,
                vulnerability.remediation_notes,
                vulnerability.false_positive,
                vulnerability.risk_score,
                json.dumps(vulnerability.tags),
                json.dumps(vulnerability.metadata)
            ))
            
            conn.commit()
            conn.close()
        
        except Exception as e:
            logger.error(f"Error saving vulnerability: {e}")
    
    def _save_scan(self, scan: VulnerabilityScan):
        """Save scan to database"""
        try:
            conn = sqlite3.connect(self.vuln_db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO vulnerability_scans VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                scan.scan_id,
                scan.scan_type.value,
                json.dumps(scan.target_systems),
                json.dumps(scan.target_services),
                json.dumps(scan.scan_configuration),
                scan.schedule_type.value,
                json.dumps(scan.schedule_config),
                scan.status.value,
                scan.start_time.isoformat() if scan.start_time else None,
                scan.end_time.isoformat() if scan.end_time else None,
                scan.duration,
                scan.vulnerabilities_found,
                scan.critical_vulnerabilities,
                scan.high_vulnerabilities,
                scan.medium_vulnerabilities,
                scan.low_vulnerabilities,
                json.dumps(scan.scan_results),
                scan.scan_log,
                scan.error_message,
                scan.created_by,
                scan.created_at.isoformat(),
                scan.updated_at.isoformat()
            ))
            
            conn.commit()
            conn.close()
        
        except Exception as e:
            logger.error(f"Error saving scan: {e}")
    
    def _save_schedule(self, schedule: VulnerabilitySchedule):
        """Save schedule to database"""
        try:
            conn = sqlite3.connect(self.vuln_db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO vulnerability_schedules VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                schedule.schedule_id,
                schedule.name,
                schedule.description,
                schedule.scan_type.value,
                schedule.schedule_type.value,
                json.dumps(schedule.schedule_config),
                json.dumps(schedule.target_systems),
                json.dumps(schedule.target_services),
                json.dumps(schedule.scan_configuration),
                schedule.enabled,
                schedule.last_run.isoformat() if schedule.last_run else None,
                schedule.next_run.isoformat() if schedule.next_run else None,
                schedule.created_by,
                schedule.created_at.isoformat(),
                schedule.updated_at.isoformat()
            ))
            
            conn.commit()
            conn.close()
        
        except Exception as e:
            logger.error(f"Error saving schedule: {e}")
    
    def _update_scan(self, scan: VulnerabilityScan):
        """Update scan in database"""
        scan.updated_at = datetime.utcnow()
        self._save_scan(scan)
    
    def _update_schedule(self, schedule: VulnerabilitySchedule):
        """Update schedule in database"""
        schedule.updated_at = datetime.utcnow()
        self._save_schedule(schedule)

def create_vulnerability_management_system(base_url: str = "http://localhost:5000") -> VulnerabilityManagementSystem:
    """Create vulnerability management system instance"""
    return VulnerabilityManagementSystem(base_url)

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Vulnerability Management System")
    parser.add_argument("--base-url", default="http://localhost:5000", help="Base URL for system")
    parser.add_argument("--create-scan", action="store_true", help="Create vulnerability scan")
    parser.add_argument("--create-schedule", action="store_true", help="Create vulnerability schedule")
    parser.add_argument("--execute-scan", action="store_true", help="Execute vulnerability scan")
    parser.add_argument("--scan-type", default="network", help="Scan type")
    parser.add_argument("--targets", nargs="+", default=["localhost"], help="Scan targets")
    parser.add_argument("--schedule-type", default="daily", help="Schedule type")
    parser.add_argument("--schedule-name", default="Daily Network Scan", help="Schedule name")
    
    args = parser.parse_args()
    
    # Create vulnerability management system
    vuln_system = create_vulnerability_management_system(args.base_url)
    
    if args.create_scan:
        # Create vulnerability scan
        print("Creating vulnerability scan...")
        scan = vuln_system.create_vulnerability_scan(
            scan_type=ScanType(args.scan_type),
            targets=args.targets,
            created_by="system"
        )
        
        if scan:
            print(f"Scan created: {scan.scan_id}")
            print(f"Scan type: {scan.scan_type.value}")
            print(f"Targets: {scan.target_systems}")
            print(f"Status: {scan.status.value}")
        else:
            print("Failed to create scan")
    
    elif args.create_schedule:
        # Create vulnerability schedule
        print("Creating vulnerability schedule...")
        schedule = vuln_system.create_vulnerability_schedule(
            name=args.schedule_name,
            scan_type=ScanType(args.scan_type),
            schedule_type=ScheduleType(args.schedule_type),
            targets=args.targets,
            created_by="system"
        )
        
        if schedule:
            print(f"Schedule created: {schedule.schedule_id}")
            print(f"Name: {schedule.name}")
            print(f"Scan type: {schedule.scan_type.value}")
            print(f"Schedule type: {schedule.schedule_type.value}")
            print(f"Next run: {schedule.next_run}")
        else:
            print("Failed to create schedule")
    
    elif args.execute_scan:
        # Execute vulnerability scan
        print("Executing vulnerability scan...")
        scan = vuln_system.create_vulnerability_scan(
            scan_type=ScanType(args.scan_type),
            targets=args.targets,
            created_by="system"
        )
        
        if scan:
            success = vuln_system.execute_scan(scan)
            if success:
                print(f"Scan executed successfully: {scan.scan_id}")
                print(f"Vulnerabilities found: {scan.vulnerabilities_found}")
                print(f"Critical: {scan.critical_vulnerabilities}")
                print(f"High: {scan.high_vulnerabilities}")
                print(f"Medium: {scan.medium_vulnerabilities}")
                print(f"Low: {scan.low_vulnerabilities}")
            else:
                print("Scan execution failed")
        else:
            print("Failed to create scan")
    
    else:
        print("Vulnerability Management System")
        print("Use --help for usage information") 