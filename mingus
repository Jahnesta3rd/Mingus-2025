#!/usr/bin/env python3
import os
import sys
import argparse
import pytest


def main():
    parser = argparse.ArgumentParser(description="Run Mingus test suite")
    parser.add_argument("--base-url", default=os.environ.get("TEST_BASE_URL", "http://localhost:5000"))
    parser.add_argument("--with-selenium", action="store_true", help="Run selenium-marked tests as well")
    parser.add_argument("--html", default=None, help="Path to write HTML report (requires pytest-html)")
    parser.add_argument("--cov", action="store_true", help="Enable coverage (requires pytest-cov)")
    args, extra = parser.parse_known_args()

    os.environ["TEST_BASE_URL"] = args.base_url
    os.environ.setdefault("CELERY_ALWAYS_EAGER", "true")
    os.environ.setdefault("CELERY_TASK_ALWAYS_EAGER", "true")
    os.environ.setdefault("CELERY_TASK_EAGER_PROPAGATES", "true")

    pytest_args = [
        "-q",
        "-ra",
        "--maxfail=1",
        "-s",
        "-c",
        os.path.join("mingus", "pytest.ini"),
        os.path.join("mingus", "tests"),
    ]

    if not args.with_selenium:
        pytest_args += ["-m", "not selenium"]

    if args.html:
        pytest_args += ["--html", args.html, "--self-contained-html"]

    if args.cov:
        pytest_args += ["--cov=.", "--cov-report=term-missing"]

    pytest_args += extra

    print("Running:", " ".join(pytest_args))
    sys.exit(pytest.main(pytest_args))


if __name__ == "__main__":
    main()

[pytest]
addopts = -q -ra --maxfail=1
markers =
    selenium: UI tests requiring a browser
testpaths =
    tests

from dataclasses import dataclass


@dataclass
class HomePage:
    driver: any

    def open(self, base_url: str):
        self.driver.get(base_url)
        return self

    def click_login(self):
        btn = self.driver.find_element("id", "loginBtn")
        btn.click()
        return self

import os
import time
import uuid
import pytest

from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.options import Options


@pytest.mark.selenium
def test_user_journey_smoke():
    base_url = os.environ.get("TEST_BASE_URL", "http://localhost:5000")

    chrome_options = Options()
    chrome_options.add_argument("--headless=new")
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument("--disable-dev-shm-usage")

    driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=chrome_options)
    try:
        driver.set_page_load_timeout(30)
        driver.get(base_url)
        assert "MINGUS" in driver.title or driver.find_element("css selector", ".logo")
    finally:
        driver.quit()

class MockTwilioClient:
    class Messages:
        @staticmethod
        def create(**kwargs):
            return type("Message", (), {"sid": "mock_sid"})

    messages = Messages()


class MockResendClient:
    class Emails:
        @staticmethod
        def send(payload):
            return type("Response", (), {"id": "mock_email_id"})

    emails = Emails()

def generate_user_payload(email: str = "test@example.com") -> dict:
    return {
        "email": email,
        "password": "S3cure!Passw0rd",
        "full_name": "Test User",
        "phone_number": "+15555550123",
    }

import requests


def test_subscription_endpoints_exist(base_url: str):
    # Light-touch checks to confirm routes exist; detailed tests should be added later
    for path in ("/api/subscription/plans", "/api/subscription/status"):
        resp = requests.get(f"{base_url}{path}")
        assert resp.status_code in (200, 401, 404)

import requests


def test_profile_completion_skeleton(base_url: str):
    # Placeholder to be expanded once authenticated client fixture is available
    resp = requests.get(f"{base_url}/api/profile")
    assert resp.status_code in (200, 401, 404)

import uuid
import pytest


class TestUserRegistration:
    """Test complete user registration flow."""

    @staticmethod
    def _make_payload(email: str | None = None) -> dict:
        return {
            "email": email or f"test_{uuid.uuid4().hex[:8]}@example.com",
            "password": "S3cure!Passw0rd",
            "first_name": "Marcus",
            "last_name": "Johnson",
            "phone_number": "+15555550123",
        }

    def test_valid_registration(self, client):
        """Test successful user registration."""
        payload = self._make_payload()
        resp = client.post("/api/auth/register", json=payload)
        assert resp.status_code in (200, 201, 302)
        if resp.status_code == 302:
            # Redirect to onboarding or dashboard indicates success
            assert resp.headers.get("Location") is not None
        else:
            data = resp.get_json() or {}
            # Some implementations may return a success JSON
            assert (data.get("success") is True) or ("error" not in data)

    def test_duplicate_email_registration(self, client):
        """Test registration with duplicate email."""
        payload = self._make_payload(email=f"dupe_{uuid.uuid4().hex[:6]}@example.com")
        first = client.post("/api/auth/register", json=payload)
        assert first.status_code in (200, 201, 302)

        # Attempt duplicate registration
        dupe = client.post("/api/auth/register", json=payload)
        # Implementation returns 409 for duplicate email
        assert dupe.status_code in (400, 409)
        data = dupe.get_json() or {}
        if data.get("error"):
            assert "email" in data["error"].lower()

    def test_invalid_email_format(self, client):
        """Test registration with invalid email format."""
        payload = self._make_payload(email="invalid-email-format")
        resp = client.post("/api/auth/register", json=payload)
        assert resp.status_code == 400
        data = resp.get_json() or {}
        assert "email" in (data.get("error", "").lower())

    def test_weak_password(self, client):
        """Test registration with weak password."""
        payload = self._make_payload()
        payload["password"] = "123"
        resp = client.post("/api/auth/register", json=payload)
        assert resp.status_code == 400
        data = resp.get_json() or {}
        assert "password" in (data.get("error", "").lower())

    @pytest.mark.parametrize("missing_field", ["email", "password", "first_name", "last_name"])
    def test_missing_required_fields(self, client, missing_field):
        """Test registration with missing required fields."""
        payload = self._make_payload()
        del payload[missing_field]
        resp = client.post("/api/auth/register", json=payload)
        assert resp.status_code == 400
        data = resp.get_json() or {}
        assert missing_field in (data.get("error", "").lower())

import pytest


class TestAPIEndpoints:
    """Test all API endpoints for basic functionality."""

    def test_health_endpoint(self, client):
        """Test application health check."""
        # Try common health endpoints registered in the app
        for path in ("/api/health", "/health", "/api/system/health"):
            resp = client.get(path)
            if resp.status_code != 404:
                break
        assert resp.status_code == 200
        data = resp.get_json() or {}
        assert data.get("status", "healthy").lower() in ("healthy", "ok")

    def test_get_user_profile_unauthorized(self, client):
        """Test getting user profile without authentication."""
        resp = client.get("/api/auth/profile")
        assert resp.status_code in (401, 403)

    def test_get_user_profile_authorized(self, client, authenticated_user):
        """Test getting user profile with authentication (session cookie)."""
        resp = client.get("/api/auth/profile")
        assert resp.status_code == 200
        data = resp.get_json()
        assert "profile" in data

    def test_update_user_profile(self, client, authenticated_user):
        """Test updating user profile."""
        update_data = {
            "first_name": "Updated",
            "monthly_income": 75000,
            "dependents": 1,
        }
        resp = client.put("/api/auth/profile", json=update_data)
        assert resp.status_code in (200, 204)
        data = resp.get_json() or {"success": True}
        assert data.get("success", True) is True

    def test_onboarding_progress(self, client, authenticated_user):
        """Test onboarding progress tracking."""
        resp = client.get("/api/user/onboarding")
        assert resp.status_code in (200, 404)
        if resp.status_code == 200:
            data = resp.get_json()
            assert "onboarding" in data

import os
import tempfile
import pytest

from backend.app_factory import create_app
from backend.database import init_app_database, create_tables, drop_tables
from backend.models import User, UserProfile  # noqa: F401 (ensure models are imported)


@pytest.fixture(scope="session")
def app():
    """Create and configure a new app instance for each test session."""
    # Create a temporary file to serve as the database
    db_fd, db_path = tempfile.mkstemp()
    sqlite_uri = f"sqlite:///{db_path}"

    # Create the app with test config
    flask_app = create_app("testing")
    flask_app.config.update(
        TESTING=True,
        SECRET_KEY="test-secret-key",
        WTF_CSRF_ENABLED=False,
        DATABASE_URL=sqlite_uri,
        SQLALCHEMY_DATABASE_URI=sqlite_uri,
        SQLALCHEMY_TRACK_MODIFICATIONS=False,
        CREATE_TABLES=True,
        BYPASS_AUTH=True,
    )

    # Initialize the database and create tables
    with flask_app.app_context():
        init_app_database(flask_app)
        create_tables()

    yield flask_app

    # Clean up
    try:
        with flask_app.app_context():
            drop_tables()
    except Exception:
        pass
    os.close(db_fd)
    os.unlink(db_path)


@pytest.fixture
def client(app):
    """A test client for the app."""
    return app.test_client()


@pytest.fixture
def runner(app):
    """A test runner for the app's Click commands."""
    return app.test_cli_runner()


@pytest.fixture
def sample_user_data():
    """Sample user data for testing."""
    return {
        "email": "test@mingus.com",
        "password": "TestPassword123!",
        "first_name": "Marcus",
        "last_name": "Johnson",
        "zip_code": "30309",
        "monthly_income": 65000,
        "industry": "Technology",
        "job_title": "Software Developer",
        "phone_number": "+15555550123",
    }


@pytest.fixture
def authenticated_user(client, sample_user_data):
    """Create and authenticate a test user."""
    # Register user
    response = client.post("/api/auth/register", json=sample_user_data)
    assert response.status_code in (200, 201, 302)

    # Login user
    login_response = client.post(
        "/api/auth/login",
        json={
            "email": sample_user_data["email"],
            "password": sample_user_data["password"],
        },
    )
    assert login_response.status_code == 200
    return login_response.get_json()

"""Test package initializer for the Mingus dedicated test suite."""


